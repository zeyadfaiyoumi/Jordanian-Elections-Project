"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenAPIGenerator = void 0;
const lodash_1 = require("./lib/lodash");
const errors_1 = require("./errors");
const zod_is_type_1 = require("./lib/zod-is-type");
const enum_info_1 = require("./lib/enum-info");
// List of Open API Versions. Please make sure these are in ascending order
const openApiVersions = ['3.0.0', '3.0.1', '3.0.2', '3.0.3', '3.1.0'];
class OpenAPIGenerator {
    constructor(definitions, openAPIVersion) {
        this.definitions = definitions;
        this.openAPIVersion = openAPIVersion;
        this.schemaRefs = {};
        this.paramRefs = {};
        this.pathRefs = {};
        this.webhookRefs = {};
        this.rawComponents = [];
        this.openApiVersionSatisfies = (inputVersion, comparison) => openApiVersions.indexOf(inputVersion) >=
            openApiVersions.indexOf(comparison);
        this.sortDefinitions();
    }
    generateDocument(config) {
        this.definitions.forEach(definition => this.generateSingle(definition));
        return Object.assign(Object.assign(Object.assign({}, config), { openapi: this.openAPIVersion, components: this.buildComponents(), paths: this.pathRefs }), (Object.keys(this.webhookRefs).length && {
            webhooks: this.webhookRefs,
        }));
    }
    generateComponents() {
        this.definitions.forEach(definition => this.generateSingle(definition));
        return {
            components: this.buildComponents(),
        };
    }
    buildComponents() {
        var _a, _b;
        const rawComponents = {};
        this.rawComponents.forEach(({ componentType, name, component }) => {
            var _a;
            (_a = rawComponents[componentType]) !== null && _a !== void 0 ? _a : (rawComponents[componentType] = {});
            rawComponents[componentType][name] = component;
        });
        return Object.assign(Object.assign({}, rawComponents), { schemas: Object.assign(Object.assign({}, ((_a = rawComponents.schemas) !== null && _a !== void 0 ? _a : {})), this.schemaRefs), parameters: Object.assign(Object.assign({}, ((_b = rawComponents.parameters) !== null && _b !== void 0 ? _b : {})), this.paramRefs) });
    }
    sortDefinitions() {
        const generationOrder = [
            'schema',
            'parameter',
            'component',
            'route',
            'webhook',
        ];
        this.definitions.sort((left, right) => {
            const leftIndex = generationOrder.findIndex(type => type === left.type);
            const rightIndex = generationOrder.findIndex(type => type === right.type);
            return leftIndex - rightIndex;
        });
    }
    generateSingle(definition) {
        switch (definition.type) {
            case 'parameter':
                this.generateParameterDefinition(definition.schema);
                return;
            case 'schema':
                this.generateSchemaDefinition(definition.schema);
                return;
            case 'route':
                this.generateSingleRoute(definition.route);
                return;
            case 'webhook':
                this.generateSingleWebhook(definition.webhook);
                return;
            case 'component':
                this.rawComponents.push(definition);
                return;
        }
    }
    generateParameterDefinition(zodSchema) {
        const metadata = this.getInternalMetadata(zodSchema);
        const result = this.generateParameter(zodSchema);
        if (metadata === null || metadata === void 0 ? void 0 : metadata.refId) {
            this.paramRefs[metadata.refId] = result;
        }
        return result;
    }
    getParameterRef(schemaMetadata, external) {
        var _a, _b, _c, _d, _e;
        const parameterMetadata = (_a = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata.metadata) === null || _a === void 0 ? void 0 : _a.param;
        const existingRef = ((_b = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _b === void 0 ? void 0 : _b.refId)
            ? this.paramRefs[(_c = schemaMetadata._internal) === null || _c === void 0 ? void 0 : _c.refId]
            : undefined;
        if (!((_d = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _d === void 0 ? void 0 : _d.refId) || !existingRef) {
            return undefined;
        }
        if ((parameterMetadata && existingRef.in !== parameterMetadata.in) ||
            ((external === null || external === void 0 ? void 0 : external.in) && existingRef.in !== external.in)) {
            throw new errors_1.ConflictError(`Conflicting location for parameter ${existingRef.name}`, {
                key: 'in',
                values: (0, lodash_1.compact)([
                    existingRef.in,
                    external === null || external === void 0 ? void 0 : external.in,
                    parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in,
                ]),
            });
        }
        if ((parameterMetadata && existingRef.name !== parameterMetadata.name) ||
            ((external === null || external === void 0 ? void 0 : external.name) && existingRef.name !== (external === null || external === void 0 ? void 0 : external.name))) {
            throw new errors_1.ConflictError(`Conflicting names for parameter`, {
                key: 'name',
                values: (0, lodash_1.compact)([
                    existingRef.name,
                    external === null || external === void 0 ? void 0 : external.name,
                    parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.name,
                ]),
            });
        }
        return {
            $ref: `#/components/parameters/${(_e = schemaMetadata._internal) === null || _e === void 0 ? void 0 : _e.refId}`,
        };
    }
    generateInlineParameters(zodSchema, location) {
        var _a;
        const metadata = this.getMetadata(zodSchema);
        const parameterMetadata = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a === void 0 ? void 0 : _a.param;
        const referencedSchema = this.getParameterRef(metadata, { in: location });
        if (referencedSchema) {
            return [referencedSchema];
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodObject')) {
            const propTypes = zodSchema._def.shape();
            const parameters = Object.entries(propTypes).map(([key, schema]) => {
                var _a, _b;
                const innerMetadata = this.getMetadata(schema);
                const referencedSchema = this.getParameterRef(innerMetadata, {
                    in: location,
                    name: key,
                });
                if (referencedSchema) {
                    return referencedSchema;
                }
                const innerParameterMetadata = (_a = innerMetadata === null || innerMetadata === void 0 ? void 0 : innerMetadata.metadata) === null || _a === void 0 ? void 0 : _a.param;
                if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.name) &&
                    innerParameterMetadata.name !== key) {
                    throw new errors_1.ConflictError(`Conflicting names for parameter`, {
                        key: 'name',
                        values: [key, innerParameterMetadata.name],
                    });
                }
                if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.in) &&
                    innerParameterMetadata.in !== location) {
                    throw new errors_1.ConflictError(`Conflicting location for parameter ${(_b = innerParameterMetadata.name) !== null && _b !== void 0 ? _b : key}`, {
                        key: 'in',
                        values: [location, innerParameterMetadata.in],
                    });
                }
                return this.generateParameter(schema.openapi({ param: { name: key, in: location } }));
            });
            return parameters;
        }
        if ((parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in) && parameterMetadata.in !== location) {
            throw new errors_1.ConflictError(`Conflicting location for parameter ${parameterMetadata.name}`, {
                key: 'in',
                values: [location, parameterMetadata.in],
            });
        }
        return [
            this.generateParameter(zodSchema.openapi({ param: { in: location } })),
        ];
    }
    generateParameter(zodSchema) {
        var _a;
        const metadata = this.getMetadata(zodSchema);
        const paramMetadata = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a === void 0 ? void 0 : _a.param;
        const paramName = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.name;
        const paramLocation = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.in;
        if (!paramName) {
            throw new errors_1.MissingParameterDataError({ missingField: 'name' });
        }
        if (!paramLocation) {
            throw new errors_1.MissingParameterDataError({
                missingField: 'in',
                paramName,
            });
        }
        const required = !this.isOptionalSchema(zodSchema) && !zodSchema.isNullable();
        const schema = this.generateSimpleSchema(zodSchema);
        return Object.assign({ in: paramLocation, name: paramName, schema,
            required }, (paramMetadata ? this.buildParameterMetadata(paramMetadata) : {}));
    }
    /**
     * Generates an OpenAPI SchemaObject or a ReferenceObject with all the provided metadata applied
     */
    generateSimpleSchema(zodSchema) {
        var _a, _b, _c, _d;
        const innerSchema = this.unwrapChained(zodSchema);
        const metadata = (_a = zodSchema._def.openapi) !== null && _a !== void 0 ? _a : innerSchema._def.openapi;
        const defaultValue = this.getDefaultValue(zodSchema);
        const refId = (_b = metadata === null || metadata === void 0 ? void 0 : metadata._internal) === null || _b === void 0 ? void 0 : _b.refId;
        if (refId && this.schemaRefs[refId]) {
            const schemaRef = this.schemaRefs[refId];
            const referenceObject = {
                $ref: `#/components/schemas/${refId}`,
            };
            // New metadata from .openapi()
            const newMetadata = (0, lodash_1.omitBy)(
            // We do not want to check our "custom" metadata fields. We only want
            // the plain metadata for a SchemaObject.
            this.buildSchemaMetadata((_c = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) !== null && _c !== void 0 ? _c : {}), (value, key) => value === undefined || (0, lodash_1.objectEquals)(value, schemaRef[key]));
            // New metadata from ZodSchema properties.
            // Do not calculate schema metadata overrides if type is provided in .openapi
            // https://github.com/asteasolutions/zod-to-openapi/pull/52/files/8ff707fe06e222bc573ed46cf654af8ee0b0786d#r996430801
            const newSchemaMetadata = !newMetadata.type
                ? (0, lodash_1.omitBy)(this.constructReferencedOpenAPISchema(zodSchema, innerSchema, defaultValue), (value, key) => value === undefined || (0, lodash_1.objectEquals)(value, schemaRef[key]))
                : {};
            const appliedMetadata = this.applySchemaMetadata(newSchemaMetadata, newMetadata);
            if (Object.keys(appliedMetadata).length > 0) {
                return {
                    allOf: [referenceObject, appliedMetadata],
                };
            }
            return referenceObject;
        }
        const result = ((_d = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _d === void 0 ? void 0 : _d.type)
            ? {
                type: metadata === null || metadata === void 0 ? void 0 : metadata.metadata.type,
            }
            : this.toOpenAPISchema(innerSchema, zodSchema.isNullable(), defaultValue);
        return (metadata === null || metadata === void 0 ? void 0 : metadata.metadata)
            ? this.applySchemaMetadata(result, metadata.metadata)
            : (0, lodash_1.omitBy)(result, lodash_1.isNil);
    }
    generateInnerSchema(zodSchema, metadata) {
        const simpleSchema = this.generateSimpleSchema(zodSchema);
        if ('$ref' in simpleSchema && simpleSchema.$ref) {
            return simpleSchema;
        }
        return metadata
            ? this.applySchemaMetadata(simpleSchema, metadata)
            : simpleSchema;
    }
    generateSchemaDefinition(zodSchema) {
        var _a;
        const metadata = this.getMetadata(zodSchema);
        const refId = (_a = metadata === null || metadata === void 0 ? void 0 : metadata._internal) === null || _a === void 0 ? void 0 : _a.refId;
        const simpleSchema = this.generateSimpleSchema(zodSchema);
        const result = (metadata === null || metadata === void 0 ? void 0 : metadata.metadata)
            ? this.applySchemaMetadata(simpleSchema, metadata.metadata)
            : simpleSchema;
        if (refId) {
            this.schemaRefs[refId] = result;
        }
        return result;
    }
    getRequestBody(requestBody) {
        if (!requestBody) {
            return;
        }
        const { content } = requestBody, rest = __rest(requestBody, ["content"]);
        const requestBodyContent = this.getBodyContent(content);
        return Object.assign(Object.assign({}, rest), { content: requestBodyContent });
    }
    getParameters(request) {
        var _a, _b;
        if (!request) {
            return [];
        }
        const queryParameters = request.query
            ? this.generateInlineParameters(request.query, 'query')
            : [];
        const pathParameters = request.params
            ? this.generateInlineParameters(request.params, 'path')
            : [];
        const headerParameters = (_b = (_a = request.headers) === null || _a === void 0 ? void 0 : _a.flatMap(header => this.generateInlineParameters(header, 'header'))) !== null && _b !== void 0 ? _b : [];
        return [...pathParameters, ...queryParameters, ...headerParameters];
    }
    generatePath(route) {
        const { method, path, request, responses } = route, pathItemConfig = __rest(route, ["method", "path", "request", "responses"]);
        const generatedResponses = (0, lodash_1.mapValues)(responses, response => {
            return this.getResponse(response);
        });
        const parameters = this.getParameters(request);
        const requestBody = this.getRequestBody(request === null || request === void 0 ? void 0 : request.body);
        const routeDoc = {
            [method]: Object.assign(Object.assign(Object.assign(Object.assign({}, pathItemConfig), (parameters.length > 0 ? { parameters } : {})), (requestBody ? { requestBody } : {})), { responses: generatedResponses }),
        };
        return routeDoc;
    }
    generateSingleRoute(route) {
        const routeDoc = this.generatePath(route);
        this.pathRefs[route.path] = Object.assign(Object.assign({}, this.pathRefs[route.path]), routeDoc);
        return routeDoc;
    }
    generateSingleWebhook(route) {
        const routeDoc = this.generatePath(route);
        this.webhookRefs[route.path] = Object.assign(Object.assign({}, this.webhookRefs[route.path]), routeDoc);
        return routeDoc;
    }
    getResponse(_a) {
        var { content } = _a, rest = __rest(_a, ["content"]);
        const responseContent = content
            ? { content: this.getBodyContent(content) }
            : {};
        return Object.assign(Object.assign({}, rest), responseContent);
    }
    getBodyContent(content) {
        return (0, lodash_1.mapValues)(content, config => {
            if (!(0, zod_is_type_1.isAnyZodType)(config.schema)) {
                return { schema: config.schema };
            }
            const schema = this.generateInnerSchema(config.schema);
            return { schema };
        });
    }
    getZodStringCheck(zodString, kind) {
        return zodString._def.checks.find((check) => {
            return check.kind === kind;
        });
    }
    /**
     * Attempts to map Zod strings to known formats
     * https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats
     */
    mapStringFormat(zodString) {
        if (zodString.isUUID) {
            return 'uuid';
        }
        if (zodString.isEmail) {
            return 'email';
        }
        if (zodString.isURL) {
            return 'uri';
        }
        if (zodString.isDatetime) {
            return 'date-time';
        }
        return undefined;
    }
    mapDiscriminator(zodObjects, discriminator) {
        // All schemas must be registered to use a discriminator
        if (zodObjects.some(obj => { var _a, _b; return ((_b = (_a = obj._def.openapi) === null || _a === void 0 ? void 0 : _a._internal) === null || _b === void 0 ? void 0 : _b.refId) === undefined; })) {
            return undefined;
        }
        const mapping = {};
        zodObjects.forEach(obj => {
            var _a, _b, _c, _d;
            const value = (_b = (_a = obj.shape) === null || _a === void 0 ? void 0 : _a[discriminator]) === null || _b === void 0 ? void 0 : _b._def.value;
            // This should never happen because Zod checks the disciminator type but to keep the types happy
            if (typeof value !== 'string') {
                throw new Error(`Discriminator ${discriminator} could not be found in one of the values of a discriminated union`);
            }
            mapping[value] = `#/components/schemas/${(_d = (_c = obj._def.openapi) === null || _c === void 0 ? void 0 : _c._internal) === null || _d === void 0 ? void 0 : _d.refId}`;
        });
        return {
            propertyName: discriminator,
            mapping,
        };
    }
    mapNullableOfArray(objects, isNullable) {
        if (isNullable) {
            if (this.openApiVersionSatisfies(this.openAPIVersion, '3.1.0')) {
                return [...objects, { type: 'null' }];
            }
            return [...objects, { nullable: true }];
        }
        return objects;
    }
    mapNullableType(type, isNullable) {
        // Open API 3.1.0 made the `nullable` key invalid and instead you use type arrays
        if (isNullable &&
            this.openApiVersionSatisfies(this.openAPIVersion, '3.1.0')) {
            return {
                type: Array.isArray(type) ? [...type, 'null'] : [type, 'null'],
            };
        }
        return {
            type,
            nullable: isNullable ? true : undefined,
        };
    }
    getNumberChecks(checks) {
        return Object.assign({}, ...checks.map(check => {
            switch (check.kind) {
                case 'min':
                    return check.inclusive
                        ? { minimum: check.value }
                        : this.openApiVersionSatisfies(this.openAPIVersion, '3.1.0')
                            ? { exclusiveMinimum: check.value }
                            : { minimum: check.value, exclusiveMinimum: true };
                case 'max':
                    return check.inclusive
                        ? { maximum: check.value }
                        : this.openApiVersionSatisfies(this.openAPIVersion, '3.1.0')
                            ? { exclusiveMaximum: check.value }
                            : { maximum: check.value, exclusiveMaximum: true };
                default:
                    return {};
            }
        }));
    }
    constructReferencedOpenAPISchema(zodSchema, innerSchema, defaultValue) {
        var _a, _b;
        const isNullableSchema = zodSchema.isNullable();
        const metadata = (_a = zodSchema._def.openapi) !== null && _a !== void 0 ? _a : innerSchema._def.openapi;
        if ((_b = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _b === void 0 ? void 0 : _b.type) {
            return this.mapNullableType(metadata.metadata.type, isNullableSchema);
        }
        return this.toOpenAPISchema(innerSchema, isNullableSchema, defaultValue);
    }
    toOpenAPISchema(zodSchema, isNullable, defaultValue) {
        var _a, _b, _c, _d, _e, _f;
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodNull')) {
            return { type: 'null' };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodString')) {
            const regexCheck = this.getZodStringCheck(zodSchema, 'regex');
            return Object.assign(Object.assign({}, this.mapNullableType('string', isNullable)), { 
                // FIXME: https://github.com/colinhacks/zod/commit/d78047e9f44596a96d637abb0ce209cd2732d88c
                minLength: Number.isFinite(zodSchema.minLength)
                    ? (_a = zodSchema.minLength) !== null && _a !== void 0 ? _a : undefined
                    : undefined, maxLength: Number.isFinite(zodSchema.maxLength)
                    ? (_b = zodSchema.maxLength) !== null && _b !== void 0 ? _b : undefined
                    : undefined, format: this.mapStringFormat(zodSchema), pattern: regexCheck === null || regexCheck === void 0 ? void 0 : regexCheck.regex.source, default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodNumber')) {
            return Object.assign(Object.assign(Object.assign({}, this.mapNullableType(zodSchema.isInt ? 'integer' : 'number', isNullable)), this.getNumberChecks(zodSchema._def.checks)), { default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodBoolean')) {
            return Object.assign(Object.assign({}, this.mapNullableType('boolean', isNullable)), { default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodEffects') &&
            (zodSchema._def.effect.type === 'refinement' ||
                zodSchema._def.effect.type === 'preprocess')) {
            const innerSchema = zodSchema._def.schema;
            return this.generateInnerSchema(innerSchema);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodLiteral')) {
            return Object.assign(Object.assign({}, this.mapNullableType(typeof zodSchema._def.value, isNullable)), { enum: [zodSchema._def.value], default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodEnum')) {
            // ZodEnum only accepts strings
            return Object.assign(Object.assign({}, this.mapNullableType('string', isNullable)), { enum: zodSchema._def.values, default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodNativeEnum')) {
            const { type, values } = (0, enum_info_1.enumInfo)(zodSchema._def.values);
            if (type === 'mixed') {
                // enum Test {
                //   A = 42,
                //   B = 'test',
                // }
                //
                // const result = z.nativeEnum(Test).parse('42');
                //
                // This is an error, so we can't just say it's a 'string'
                throw new errors_1.ZodToOpenAPIError('Enum has mixed string and number values, please specify the OpenAPI type manually');
            }
            return Object.assign(Object.assign({}, this.mapNullableType(type === 'numeric' ? 'number' : 'string', isNullable)), { enum: values, default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodObject')) {
            return this.toOpenAPIObjectSchema(zodSchema, isNullable, defaultValue);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodArray')) {
            const itemType = zodSchema._def.type;
            return Object.assign(Object.assign({}, this.mapNullableType('array', isNullable)), { items: this.generateInnerSchema(itemType), minItems: (_c = zodSchema._def.minLength) === null || _c === void 0 ? void 0 : _c.value, maxItems: (_d = zodSchema._def.maxLength) === null || _d === void 0 ? void 0 : _d.value, default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodUnion')) {
            const options = this.flattenUnionTypes(zodSchema);
            return {
                anyOf: this.mapNullableOfArray(options.map(schema => this.generateInnerSchema(schema)), isNullable),
                default: defaultValue,
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodDiscriminatedUnion')) {
            const options = [...zodSchema.options.values()];
            const optionSchema = options.map(schema => this.generateInnerSchema(schema));
            if (isNullable) {
                return {
                    oneOf: this.mapNullableOfArray(optionSchema, isNullable),
                    default: defaultValue,
                };
            }
            return {
                oneOf: optionSchema,
                discriminator: this.mapDiscriminator(options, zodSchema.discriminator),
                default: defaultValue,
            };
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodIntersection')) {
            const subtypes = this.flattenIntersectionTypes(zodSchema);
            const allOfSchema = {
                allOf: subtypes.map(schema => this.generateInnerSchema(schema)),
            };
            if (isNullable) {
                return {
                    anyOf: this.mapNullableOfArray([allOfSchema], isNullable),
                    default: defaultValue,
                };
            }
            return Object.assign(Object.assign({}, allOfSchema), { default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodRecord')) {
            const propertiesType = zodSchema._def.valueType;
            return Object.assign(Object.assign({}, this.mapNullableType('object', isNullable)), { additionalProperties: this.generateInnerSchema(propertiesType), default: defaultValue });
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodUnknown')) {
            return {};
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodDate')) {
            return Object.assign(Object.assign({}, this.mapNullableType('string', isNullable)), { default: defaultValue });
        }
        const refId = (_f = (_e = this.getMetadata(zodSchema)) === null || _e === void 0 ? void 0 : _e._internal) === null || _f === void 0 ? void 0 : _f.refId;
        throw new errors_1.UnknownZodTypeError({
            currentSchema: zodSchema._def,
            schemaName: refId,
        });
    }
    isOptionalSchema(zodSchema) {
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodEffects')) {
            return this.isOptionalSchema(zodSchema._def.schema);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodDefault')) {
            return this.isOptionalSchema(zodSchema._def.innerType);
        }
        return zodSchema.isOptional();
    }
    getDefaultValue(zodSchema) {
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodOptional') ||
            (0, zod_is_type_1.isZodType)(zodSchema, 'ZodNullable')) {
            return this.getDefaultValue(zodSchema.unwrap());
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodEffects')) {
            return this.getDefaultValue(zodSchema._def.schema);
        }
        if ((0, zod_is_type_1.isZodType)(zodSchema, 'ZodDefault')) {
            return zodSchema._def.defaultValue();
        }
        return undefined;
    }
    requiredKeysOf(objectSchema) {
        return Object.entries(objectSchema._def.shape())
            .filter(([_key, type]) => !this.isOptionalSchema(type))
            .map(([key, _type]) => key);
    }
    toOpenAPIObjectSchema(zodSchema, isNullable, defaultValue) {
        var _a, _b;
        const extendedFrom = (_b = (_a = zodSchema._def.openapi) === null || _a === void 0 ? void 0 : _a._internal) === null || _b === void 0 ? void 0 : _b.extendedFrom;
        const parentShape = extendedFrom === null || extendedFrom === void 0 ? void 0 : extendedFrom.schema._def.shape();
        const childShape = zodSchema._def.shape();
        const keysRequiredByParent = extendedFrom
            ? this.requiredKeysOf(extendedFrom.schema)
            : [];
        const keysRequiredByChild = this.requiredKeysOf(zodSchema);
        const propsOfParent = parentShape
            ? (0, lodash_1.mapValues)(parentShape, _ => this.generateInnerSchema(_))
            : {};
        const propsOfChild = (0, lodash_1.mapValues)(childShape, _ => this.generateInnerSchema(_));
        const properties = Object.fromEntries(Object.entries(propsOfChild).filter(([key, type]) => {
            return !(0, lodash_1.objectEquals)(propsOfParent[key], type);
        }));
        const additionallyRequired = keysRequiredByChild.filter(prop => !keysRequiredByParent.includes(prop));
        const unknownKeysOption = zodSchema._def.unknownKeys;
        const objectData = Object.assign(Object.assign(Object.assign(Object.assign({}, this.mapNullableType('object', isNullable)), { default: defaultValue, properties }), (additionallyRequired.length > 0
            ? { required: additionallyRequired }
            : {})), (unknownKeysOption === 'strict'
            ? { additionalProperties: false }
            : {}));
        if (extendedFrom) {
            return {
                allOf: [
                    { $ref: `#/components/schemas/${extendedFrom.refId}` },
                    objectData,
                ],
            };
        }
        return objectData;
    }
    flattenUnionTypes(schema) {
        if (!(0, zod_is_type_1.isZodType)(schema, 'ZodUnion')) {
            return [schema];
        }
        const options = schema._def.options;
        return options.flatMap(option => this.flattenUnionTypes(option));
    }
    flattenIntersectionTypes(schema) {
        if (!(0, zod_is_type_1.isZodType)(schema, 'ZodIntersection')) {
            return [schema];
        }
        const leftSubTypes = this.flattenIntersectionTypes(schema._def.left);
        const rightSubTypes = this.flattenIntersectionTypes(schema._def.right);
        return [...leftSubTypes, ...rightSubTypes];
    }
    unwrapChained(schema) {
        if ((0, zod_is_type_1.isZodType)(schema, 'ZodOptional') ||
            (0, zod_is_type_1.isZodType)(schema, 'ZodNullable') ||
            (0, zod_is_type_1.isZodType)(schema, 'ZodBranded')) {
            return this.unwrapChained(schema.unwrap());
        }
        if ((0, zod_is_type_1.isZodType)(schema, 'ZodDefault')) {
            return this.unwrapChained(schema._def.innerType);
        }
        if ((0, zod_is_type_1.isZodType)(schema, 'ZodEffects') &&
            schema._def.effect.type === 'refinement') {
            return this.unwrapChained(schema._def.schema);
        }
        return schema;
    }
    /**
     * A method that omits all custom keys added to the regular OpenAPI
     * metadata properties
     */
    buildSchemaMetadata(metadata) {
        return (0, lodash_1.omitBy)((0, lodash_1.omit)(metadata, ['param']), lodash_1.isNil);
    }
    buildParameterMetadata(metadata) {
        return (0, lodash_1.omitBy)(metadata, lodash_1.isNil);
    }
    getMetadata(zodSchema) {
        const innerSchema = this.unwrapChained(zodSchema);
        const metadata = zodSchema._def.openapi
            ? zodSchema._def.openapi
            : innerSchema._def.openapi;
        return metadata;
    }
    getInternalMetadata(zodSchema) {
        const innerSchema = this.unwrapChained(zodSchema);
        const openapi = zodSchema._def.openapi
            ? zodSchema._def.openapi
            : innerSchema._def.openapi;
        return openapi === null || openapi === void 0 ? void 0 : openapi._internal;
    }
    applySchemaMetadata(initialData, metadata) {
        return (0, lodash_1.omitBy)(Object.assign(Object.assign({}, initialData), this.buildSchemaMetadata(metadata)), lodash_1.isNil);
    }
}
exports.OpenAPIGenerator = OpenAPIGenerator;
